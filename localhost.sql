--CREATE 쿼리문
CREATE TABLE EMP (
NO NUMBER, 
NAME VARCHAR2(20),
AGE NUMBER
);

ALTER TABLE EMP ADD SALARY NUMBER;
ALTER TABLE EMP MODIFY SALARY NUMBER NOT NULL;
COMMENT ON COLUMN EMP.SALARY IS '봉급';
COMMENT ON COLUMN emp.no IS '싫다';
COMMENT ON COLUMN emp.age IS '나이';
COMMENT ON COLUMN emp.name IS '이름';

INSERT INTO EMP VALUES (NULL, NULL, NULL);
INSERT INTO EMP VALUES (1, NULL, NULL);
INSERT INTO EMP VALUES (NULL, '둘리', 10);
INSERT INTO EMP VALUES (1, '둘리', 10);
INSERT INTO EMP VALUES (1, '둘리', 10);

CREATE TABLE CUSTOMER(
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(20) NOT NULL,
    ADDRESS VARCHAR2(100)
);

CREATE TABLE ORDERS(
    ORDER_ID  NUMBER PRIMARY KEY,
    SALESMAN_ID NUMBER,
    ORDER_DATE DATE NOT NULL
);
INSERT INTO ORDERS (ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1001, 1002, SYSDATE); --SYSDATE는 현재 시간
INSERT INTO ORDERS (ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1002, 1002, '2022-10-05');    --특정 시간 입력
INSERT INTO ORDERS (ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1003, 1002, TO_DATE('2022-08-08', 'YYYY-MM-DD'));   --TO_DATE 함수는 
INSERT INTO ORDERS (ORDER_ID, SALESMAN_ID, ORDER_DATE) VALUES(1004, 1002, TO_DATE('2022-08-08 10: 10: 10', 'YYYY-MM-DD HH24 : MI : SS'));

ALTER TABLE ORDERS ADD CUSTOMER_NAME VARCHAR2(50) NOT NULL;
ALTER TABLE ORDERS MODIFY SALESMAN_ID VARCHAR2(50);
ALTER TABLE ORDERS RENAME COLUMN SALESMAN_ID TO SALESMAN_NAME;
ALTER TABLE ORDERS MODIFY ORDER_DATE NULL;
COMMENT ON COLUMN orders.customer_name is '고객 이름';
COMMENT ON COLUMN orders.order_date is '날짜';
COMMENT ON COLUMN orders.order_id is '아이디';
COMMENT ON COLUMN orders.salesman_name is '직원 이름';
INSERT INTO ORDERS (ORDER_ID, SALESMAN_NAME, ORDER_DATE, CUSTOMER_NAME) VALUES (1313, '이젠마트 김씨', '2022-12-07', '이젠마트 김호갱');

--INSERT INTO 데이터 삽입
INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(1,'둘리','인천');      --일부 컬럼만 사용할 경우
INSERT INTO CUSTOMER(ID, NAME) values(3,'또치');
INSERT INTO CUSTOMER VALUES(2,'둘리','인천');       --전체 컬럼을 사용할 경우
INSERT INTO CUSTOMER VALUES(5, '둘리', '');       --공백을 넣어도 NULL로 들어감
--INSERT INTO CUSTOMER VALUES(6, '홍길동', 'NULL');

--INSERT INTO CUSTOMER(ID, NAME) VALUES(3, '홍길동');    --ID는 PK키 이므로 중복되는 값이 올 수 없다.
--INSERT INTO CUSTOMER(ID, NAME, ADDRESS) VALUES(4, '둘리', '서울');
--INSERT INTO CUSTOMER(ID, ADDRESS) VALUES(5,'서울');   --Nullable이 No인 경우엔 반드시 데이터를 넣어줘야 한다.

CREATE TABLE CATEGORIES (
    CATEGORY_ID NUMBER PRIMARY KEY,
    CATEGORY_NAME VARCHAR2(100) NOT NULL
);

CREATE TABLE LOCATION (
    LOCATION_ID NUMBER PRIMARY KEY,
    ADDRESS VARCHAR2(255) NOT NULL,
    POSTAL_CODE VARCHAR2(20),
    CITY VARCHAR2(50)
);
    
INSERT INTO CUSTOMER VALUES (6, '홍길동홍길동', NULL);

select * from nls_database_parameters where parameter = 'NLS_CHARACTERSET';

CREATE TABLE EMP2 (
    EMPNO NUMBER(5) NOT NULL,   --5자리의 정수
    NUM1 NUMBER(5), --5자리의 정수
    NUM2 NUMBER(5, 2), --5자리의 숫자 (정수 3자리, 소수점 2자리 -> 소수점 이하 3번째 자리에서 반올림)
    NUM3 NUMBER(8, -4) --5자리의 숫자 (일의 자리 0 십의 자리 -1 백의 자리 -2 천의 자리 -3에서 -3번째 숫자까지 반올림)
);

INSERT INTO EMP2 VALUES (12345, 12345, 123.23, 145555.54);

--ALTER문

ALTER TABLE CUSTOMER ADD GENDER VARCHAR2 (9);   --컬럼 추가
ALTER TABLE CUSTOMER RENAME COLUMN GENDER TO GEN;   --CUSTOMER의 GENDER를 GEN으로 이름을 바꾸었다
ALTER TABLE CUSTOMER RENAME COLUMN GEN TO GENDER;   --CUSTOMER의 GEN을 GENDER로 이름을 바꾸었다
ALTER TABLE CUSTOMER MODIFY GENDER VARCHAR2(100);   --크기 변경
ALTER TABLE CUSTOMER MODIFY GENDER VARCHAR2(100) DEFAULT 'NONE' NOT NULL;
ALTER TABLE CUSTOMER MODIFY GENDER NUMBER;  --자료형 변경
ALTER TABLE CUSTOMER MODIFY GENDER NOT NULL; --제약 조건 추가
COMMENT ON COLUMN CUSTOMER.GENDER IS '성별';  --COMMENT 추가
--ALTER TABLE CUSTOMER DROP COLUMN GENDER;  --삭제

--테이블 삭제

DROP TABLE EMP; --EMP 테이블이 삭제 되었다
DROP TABLE EMP2;
DROP TABLE CATEGORIES;
DROP TABLE CUSTOMER;
DROP TABLE LOCATION;
DROP TABLE ORDERS;

CREATE TABLE BOOK (
    BOOK_NO NUMBER PRIMARY KEY,
    TITLE VARCHAR2(30),
    PUBLISHER VARCHAR2(30),
    PRICE NUMBER NULL
);

INSERT INTO BOOK(BOOK_NO, TITLE, PUBLISHER, PRICE) VALUES (1, '역사1', '상상마당', 30000);
INSERT INTO BOOK VALUES(2, '역사2', '상상마당', 30000);
INSERT INTO BOOK VALUES(3, '스프링웹프로젝트', '한빛미디어', 50000);
INSERT INTO BOOK VALUES(4, '자바개발도서', '생능출판', NULL);

CREATE TABLE ADDRESS (
  CONTACT_NO NUMBER,
  FIRST_NAME VARCHAR2(10),
  LAST_NAME VARCHAR2(10),
  EMAIL VARCHAR2(50),
  POHNE VARCHAR2(50)
);

INSERT INTO ADDRESS VALUES (1, '이', '서연', 'flor.stone@gmail.com', '010-3171-2341');
INSERT INTO ADDRESS VALUES (2, '이', '시우', 'lavera.emerson@gmail.com', '010-3171-4111');
INSERT INTO ADDRESS VALUES (3, '김', '지호', 'shyla.ortiz@gmail.com', '010-3171-4126');
INSERT INTO ADDRESS VALUES (4, '김', '윤서', 'jeni.levy@gmail.com', '010-8121-2341');
INSERT INTO ADDRESS VALUES (5, '최', '수아', 'fern.head@gmail.com', null);


CREATE TABLE CALENDAR (
    MONTH_DAY VARCHAR2(10),
    DAY_WEEK VARCHAR2(10),
    DAY VARCHAR2(10)
);

INSERT INTO CALENDAR VALUES ('1', '일', '1');
INSERT INTO CALENDAR VALUES ('1', '월', '2');
INSERT INTO CALENDAR VALUES ('1', '화', '3');
INSERT INTO CALENDAR VALUES ('1', '수', '4');
INSERT INTO CALENDAR VALUES ('1', '목', '5');
INSERT INTO CALENDAR VALUES ('1', '금', '6');
INSERT INTO CALENDAR VALUES ('1', '토', '7');

CREATE TABLE GIFT (
    NO NUMBER,
    NAME VARCHAR2(50),
    PRICE NUMBER
);

INSERT INTO GIFT VALUES (1, '참치세트', 100000);
INSERT INTO GIFT VALUES (2, '샴푸세트', 200000);
INSERT INTO GIFT VALUES (3, '세차용품세트', 300000);
INSERT INTO GIFT VALUES (4, '주방용품세트', 400000);
INSERT INTO GIFT VALUES (5, '산악용자전거', 500000);
INSERT INTO GIFT VALUES (6, 'LCD모니터', 600000);
INSERT INTO GIFT VALUES (7, '노트북', 700000);
INSERT INTO GIFT VALUES (8, '벽걸이TV', 800000);
INSERT INTO GIFT VALUES (9, '드럼세탁기', 900000);
INSERT INTO GIFT VALUES (10, '양쪽문냉장고', 1000000);

--UPDATE

UPDATE CUSTOMER SET ADDRESS = '서울' WHERE ID=2;  --CUSTOMER 테이블에서 ID가 2인 행의 ADDRESS값을 서울로 바꿔준다
UPDATE CUSTOMER SET NAME = '훈이', ADDRESS = '제주도' WHERE ID = 3;
UPDATE ORDERS SET ORDER_DATE = SYSDATE WHERE ORDER_ID = 1002;

-- DELETE

DELETE FROM CUSTOMER WHERE ID = 4;  --ID가 4인 행 삭제
DELETE FROM CUSTOMER WHERE NAME = '둘리';
DELETE FROM CUSTOMER;   --전체 행 삭제
DELETE FROM ORDERS WHERE ORDER_ID = 1001 OR SALESMAN_ID = 2002;

INSERT INTO CUSTOMER VALUES(1, '둘리', '인천');
INSERT INTO CUSTOMER VALUES(2, '둘리', NULL);
INSERT INTO CUSTOMER VALUES(3, '홍길동', NULL);
INSERT INTO CUSTOMER VALUES(4, '또치', NULL);

UPDATE CUSTOMER SET NAME = '둘리' WHERE ID = 1 OR ID = 2 OR ID = 3 OR ID = 4;
UPDATE CUSTOMER SET ADDRESS = '인천' WHERE ID = 1 OR ID = 2 OR ID = 3 OR ID = 4;

DELETE FROM BOOK WHERE TITLE = '역사1';
DELETE FROM BOOK WHERE PRICE IS NULL;

UPDATE BOOK SET PRICE = 10000 WHERE PRICE = 30000;
UPDATE BOOK SET PRICE = 11000 WHERE TITLE = '역사2';

DELETE FROM BOOK WHERE TITLE = '자바개발도서';
DELETE FROM BOOK WHERE TITLE = '역사1' OR TITLE = '역사2' OR TITLE = '스프링웹프로젝트';


--SELECT 문

SELECT * FROM CUSTOMER; --모든 컬럼을 다 가져온다
SELECT NAME FROM CUSTOMER;  --CUSTOMER의 NAME 컬럼만 가져온다
SELECT NAME, ID FROM CUSTOMER; --CUSTOMER의 NAME, ID를 가져온다
SELECT ID, NAME FROM CUSTOMER; --위에 거랑 다르게 순서가 다르다

SELECT * FROM CUSTOMER ORDER BY ID ASC; -- ID 오름차순
SELECT * FROM CUSTOMER ORDER BY ID DESC; -- ID 내림차순
SELECT * FROM CUSTOMER ORDER BY ADDRESS ASC; --ADDRESS 오름차순

SELECT * FROM GIFT;
SELECT TYPE FROM GIFT GROUP BY TYPE;    --TYPE 컬럼을 그룹화(중복 안되는 것들만 목록으로 만듦)
SELECT TYPE, SUM(PRICE) FROM GIFT GROUP BY TYPE; --TYPE을 그룹화 한것들의 가격을 SUM(PRICE)로 더해서 나타낸다
SELECT TYPE, COUNT(NAME) AS 개수 FROM GIFT GROUP BY TYPE; -- COUNT(NAME)은 NAME 컬럼 갯수를 적어준다 AS COUNT는 열 이름을 COUNT(NAME)이 아닌 COUNT로 별칭을 해준다


--조건 검색
--비교 연산자
SELECT * FROM CUSTOMER WHERE ID = 1;
SELECT * FROM CUSTOMER WHERE ID > 1;
SELECT * FROM CUSTOMER WHERE ID < 4;
SELECT * FROM CUSTOMER WHERE ID >=1;
SELECT * FROM CUSTOMER WHERE ID <= 4;
SELECT * FROM CUSTOMER WHERE ID ! =1;

SELECT * FROM CUSTOMER WHERE NAME = '둘리';
SELECT * FROM CUSTOMER WHERE NAME > ' 둘리';  --한글도 순서 인식한다
SELECT * FROM CUSTOMER WHERE NAME < '둘리';

SELECT * FROM CUSTOMER;
SELECT * FROM CUSTOMER WHERE NAME = '둘리' AND ADDRESS = '서울';
SELECT * FROM CUSTOMER WHERE NAME = '둘리' OR ADDRESS = '서울';


SELECT * FROM ORDERS;
SELECT ORDER_ID + SALESMAN_ID AS 더한값 FROM ORDERS;
SELECT (ORDER_ID + SALESMAN_ID) * ORDER_ID AS 최종값 FROM ORDERS;

SELECT '이름:' || NAME || '입니다.' AS INTRO FROM CUSTOMER;

SELECT * FROM BOOK;
SELECT * FROM BOOK WHERE PRICE > 30000;
SELECT * FROM BOOK WHERE PRICE >= 10000 AND PRICE <= 30000;
SELECT * FROM BOOK WHERE PUBLISHER = '한빛미디어' OR PUBLISHER = '생능출판';

SELECT * FROM ORDERS;
SELECT * FROM ORDERS WHERE ORDER_DATE > '2022/01/02';
SELECT * FROM ORDERS WHERE ORDER_DATE = '2022/01/01';

SELECT * FROM CUSTOMER WHERE ID BETWEEN 2 AND 4;
SELECT * FROM CUSTOMER WHERE ID NOT BETWEEN 2 AND 4;
SELECT * FROM CUSTOMER WHERE ID IN(1, 2, 3);
SELECT * FROM CUSTOMER WHERE ID NOT IN (1, 2 ,3);

SELECT * FROM CUSTOMER WHERE NAME LIKE '둘%'; --둘로 시작하는 문자열을 출력
SELECT * FROM CUSTOMER WHERE NAME LIKE '%길%'; --중간에 길이 있는 문자열을 출력
SELECT * FROM CUSTOMER WHERE NAME LIKE '%치'; --치로 끝나는 문자열을 출력

SELECT * FROM CUSTOMER WHERE ADDRESS IS NULL;
SELECT * FROM CUSTOMER WHERE ADDRESS IS NOT NULL;

SELECT * FROM BOOK;
SELECT * FROM BOOK WHERE PRICE = 11000 OR PRICE = 25000;
SELECT * FROM BOOK WHERE PRICE >= 30000;
SELECT * FROM BOOK WHERE PRICE BETWEEN 10000 AND 30000;
SELECT * FROM BOOK WHERE PUBLISHER = '한빛미디어' OR PUBLISHER = '생능출판';
SELECT * FROM ORDERS WHERE ORDER_DATE > TO_DATE('2022-01-02');
SELECT * FROM ORDERS WHERE ORDER_DATE = TO_DATE('2022-01-01');

SELECT * FROM CONTACTS;
SELECT * FROM CONTACTS WHERE PHONE LIKE '%2341';
SELECT * FROM CONTACTS WHERE PHONE LIKE '%3171%';
SELECT * FROM CONTACTS WHERE EMAIL LIKE '%naver.com' AND PHONE IS NULL;

SELECT * FROM GIFT;
SELECT * FROM GIFT WHERE TYPE LIKE '%용품';
SELECT * FROM GIFT WHERE NAME LIKE '%세트' AND PRICE <= 300000;

SELECT * FROM CONTACTS;
SELECT * FROM CONTACTS WHERE FIRST_NAME IN('김', '최');
SELECT * FROM GIFT WHERE NAME IN ('노트북', '벽걸이TV', '양쪽문냉장고');
SELECT * FROM GIFT WHERE TYPE = '생활용품' OR TYPE = '운동장비';
SELECT * FROM GIFT WHERE PRICE BETWEEN 300000 AND 600000;


--함수

SELECT CHR(65) FROM DUAL;
SELECT LOWER('JENNIE') FROM DUAL;
--LTRIM
SELECT LTRIM('      JENNIE') FROM DUAL; --LTRIM은 왼쪽 공백을 제거하고 글자만 출력
SELECT LTRIM('블랙핑크', '블랙') FROM DUAL;   --2개를 입력하면 블랙을 제거하고 핑크만 출력
--RTRIM
SELECT RTRIM('      JENNIE') FROM DUAL; --RTRIM은 오른쪽 공백을 제거하고 글자만 출력
SELECT RTRIM('블랙핑크', '핑크') FROM DUAL; --2개를 입력하면 핑크를 제거하고 블랙만 출력
--TRIM
SELECT TRIM('   JE N N I E  ') FROM DUAL;   --TRIM은 양쪽 공백 제거
SELECT TRIM (LEADING '블' FROM '블랙핑크') FROM DUAL;    --왼쪽에서 제거 하고 싶은 것을 선택하여 제거
SELECT TRIM(TRAILING '크' FROM '블랙핑크') FROM DUAL;    --오른쪽에서 제거 하고 싶은 것을 선택하여 제거
SELECT TRIM(BOTH '블' FROM '블랙핑크블') FROM DUAL;   --양쪽에서 제거 하고 싶은 것을 선택해서 제거

SELECT SUBSTR('블랙핑크제니', 3, 2) FROM DUAL;    --3은 핑에서 시작, 2는 시작점에서 시작하여 글자를 자름
SELECT LENGTH('블랙핑크') FROM DUAL;    --문자열의 길이
SELECT REPLACE('블랙핑크제니', '제니', '지수') FROM DUAL; --제니를 지수로 바꿈
SELECT REPLACE('블랙핑크제니', '제니') FROM DUAL;   --제니를 대체할 문자가 없으니 삭제
SELECT REPLACE(LAST_NAME, '시') FROM CONTACTS;   --시가 포함된 마지막 글자 삭제

SELECT ABS(-1) FROM DUAL;
SELECT SIGN(0) FROM DUAL;

SELECT ROUND(163.76, 1) FROM DUAL;  --ROUND의 1은 소수점 기준 소수점 첫번째 자리가 반올림 OR -2는 소수점기준 10의 자리에서 반올림
SELECT TRUNC(54.29, 1) FROM DUAL; --TRUNC는 소수점 기준 첫번째 자리가 버림
SELECT CEIL(54.29) FROM DUAL; -- CEIL은 무조건 정수로 올려준다
SELECT FLOOR(54.29) FROM DUAL; --FLOOR는 무조건 소수점 버림
SELECT MOD(12, 7) FROM DUAL; --나머지 값을 나타낸다 12%7처럼

SELECT EXTRACT(YEAR FROM SYSDATE) AS YEAR FROM DUAL;    --현재 년도 출력
SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR FROM ORDERS;   --ORDERS의 ORDER_DATE의 년도만 출력

SELECT ADD_MONTHS(TO_DATE('2021-12-31', 'YYYY-MM-DD'), -1) FROM DUAL;

SELECT TO_NUMBER('1234') AS 숫자로_강제_형변환 FROM DUAL; --문자형 1234를 숫자형으로 형변환 해줬다
SELECT TO_CHAR(1234) FROM DUAL; --숫자형 1234를 문자형으로 형변환 해줬다
SELECT TO_CHAR(SYSDATE, 'DD-MM-YYYY') FROM DUAL; --SYSDATE는 DATE형인데 DATE형은 YYYY-MM-DD 형식밖에 안되지만 문자형으로 형변환하면 형식을 바꿀 수 있다

SELECT NAME, NVL(ADDRESS, '주소 없음') AS ADDRESS FROM CUSTOMER;  --ADDRESS에 NULL값이 있으면 '주소 없음' 문구를 띄운다
SELECT NAME, NULLIF(ADDRESS, '인천') AS ADDRESS FROM CUSTOMER;    --ADDRESS에 NULL값이 있으면 '인천' 문구를 띄운다

SELECT NAME, COALESCE(NAME, ADDRESS) AS ADDRESS FROM CUSTOMER;  --NAME에 널이 아니면 그다음 비교 컬럼 값에 NAME값을 그대로 넣어준다

--IF 문처럼
SELECT ID, DECODE(ID, 1, 'BLUE', 2, 'RED', 3, 'YELLOW', 4, 'BLACK', 5, 'WHITE') FROM CUSTOMER;  --DECODE는 ID에 순서, 값을 넣어준다

--SWITCH 문처럼
SELECT ID,
    CASE WHEN ID=1 THEN 'BLUE'
             WHEN ID=2 THEN 'RED'
             WHEN ID=3 THEN 'YELLOW'
             WHEN ID=4 THEN 'BLACK'
             ELSE 'WHITE'
     END AS TEST
FROM CUSTOMER;


--문제 풀기
--1번 답 : 3번
--2번 답 : 1번
--3번 답 : 3번
--4번 답 : 2번
--5번 답 : 
SELECT NAME,
    CASE WHEN NAME = '둘리' THEN 'BLUE'
             WHEN NAME = '또치' THEN 'RED'
             ELSE 'WHITE'
    END AS 출력
FROM CUSTOMER


--부서 테이블 만들기
CREATE TABLE DEPT (
    DEPT_NO NUMBER PRIMARY KEY, --부서 번호
    DEPT_NAME VARCHAR2(20) NOT NULL,    --부서명
    DEPT_ADDRESS VARCHAR2(100)  --부서주소
);

INSERT INTO DEPT (DEPT_NO, DEPT_NAME) VALUES(1, '인사부');
INSERT INTO DEPT (DEPT_NO, DEPT_NAME) VALUES(2, '연구부');
INSERT INTO DEPT (DEPT_NO, DEPT_NAME) VALUES(3, '홍보부');
INSERT INTO DEPT (DEPT_NO, DEPT_NAME) VALUES(4, '개발부');

--사원 테이블 만들기
CREATE TABLE EMP2(
    EMP2_NO NUMBER PRIMARY KEY,      --사원번호
    EMP2_NAME VARCHAR2(20) NOT NULL, --사원명
    DEPT_NO NUMBER NOT NULL,        --부서번호 (외래키 : 다른 테이블에서 온 것)
    CONSTRAINT FK_DEPT_NO FOREIGN KEY(DEPT_NO) REFERENCES DEPT(DEPT_NO) --DEPT_NO를 외래키로 설정 (제약조건)
);

INSERT INTO EMP2 VALUES (1001, '정소화', 3);    --부서 번호는 외래키 이기 때문에 입력된 외래키만 가져 올 수 있다
INSERT INTO EMP2 VALUES (1002, '김용욱', 1);
INSERT INTO EMP2 VALUES (1003, '고명석', 2);
INSERT INTO EMP2 VALUES (1004, '김연아', 4); --무결성(위반) 외래키에 입력된 4가 없기 때문에 오류 뜸

SELECT * FROM EMP2;

UPDATE EMP2 SET DEPT_NO = 3 WHERE EMP2_NAME='정소화';  --오류 발생, 외래키가 먼저 바뀌면 안된다

DELETE FROM DEPT WHERE DEPT_NO = 1; --현재 외래키로 입력된 DEPT_NO = 1인 것이 데이터에 입력되었기 때문에 바꿀 수 없다
DELETE FROM EMP2 WHERE DEPT_NO = 1; --삭제 되었다


DROP TABLE EMP2;
DROP TABLE DEPT;    --에러 발생 (이유: 컬럼부터 지우고 테이블을 지워야한다)
DROP TABLE DEPT CASCADE CONSTRAINTS;


--문제 풀이
--1번 답 :
CREATE TABLE CLASS (
    CLASS_NO NUMBER PRIMARY KEY,
    CLASS_NAME VARCHAR2(20)
);

DROP TABLE CLASS;

INSERT INTO CLASS VALUES (1001, '수학');
INSERT INTO CLASS VALUES (1002, '국어');
SELECT * FROM CLASS;

--2번 답 :
CREATE TABLE STUDENT (
    STUDENT_NO NUMBER PRIMARY KEY,
    STUDENT_NAME VARCHAR2(20)
);


INSERT INTO STUDENT VALUES (2001, '정소화');
INSERT INTO STUDENT VALUES (2002, '김용욱');
INSERT INTO STUDENT VALUES (2003, '고명석');
SELECT * FROM STUDENT;

--3번 답 :
CREATE TABLE CLASS_STUDENT(
    CS_NO NUMBER PRIMARY KEY,
    CLASS_NO NUMBER,
    STUDENT_NO NUMBER,
    CONSTRAINT FK_CLASS_NO FOREIGN KEY(CLASS_NO) REFERENCES CLASS(CLASS_NO),
    CONSTRAINT FK_STUDENT_NO FOREIGN KEY(STUDENT_NO) REFERENCES STUDENT(STUDENT_NO)
);

INSERT INTO CLASS_STUDENT VALUES (1, 1001, 2001);
INSERT INTO CLASS_STUDENT VALUES (2, 1002, 2001);
INSERT INTO CLASS_STUDENT VALUES (3, 1001, 2002);
INSERT INTO CLASS_STUDENT VALUES (4, 1002, 2002);
INSERT INTO CLASS_STUDENT VALUES (5, 1002, 2003);

SELECT * FROM CLASS_STUDENT;

-------------------------------------------

CREATE TABLE ACADEMY_A (
    STUDENT_NO NUMBER PRIMARY KEY,
    STUDENT_NAME VARCHAR2(20) NOT NULL
);

INSERT INTO ACADEMY_A VALUES (1001, '정소화');
INSERT INTO ACADEMY_A VALUES (1002, '김용욱');
INSERT INTO ACADEMY_A VALUES (1003, '고명석'); --JOIN (데이터 묶음)
INSERT INTO ACADEMY_A VALUES (1004, '김연아'); --JOIN (데이터 묶음)


CREATE TABLE ACADEMY_B (
    STUDENT_NO NUMBER PRIMARY KEY,
    STUDENT_NAME VARCHAR2(20) NOT NULL
);

INSERT INTO ACADEMY_B VALUES (1005, '김태환');
INSERT INTO ACADEMY_B VALUES (1006, '이윤아');
INSERT INTO ACADEMY_B VALUES (1003, '고명석'); --JOIN (데이터 묶음)
INSERT INTO ACADEMY_B VALUES (1004, '김연아'); --JOIN (데이터 묶음)

SELECT * FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO = T2.STUDENT_NO;    --서로의 STUDENT_NO가 같은 값을 조회 (맞으면 출력, 아니면 오류)

SELECT T1.STUDENT_NO, T1.STUDENT_NAME
FROM ACADEMY_A T1
JOIN ACADEMY_B T2   --JOIN은 T1과 겹치는 부분(교집합)을 출력한다
ON(T1.STUDENT_NO = T2.STUDENT_NO);--ON()함수는 WHERE과 같다

--SELECT * FROM ACADEMY_A T1, ACADEMY_B T2
--WHERE T1.STUDENT_NO > 1003;

SELECT *
FROM ACADEMY_A T1
LEFT JOIN ACADEMY_B T2  --LEFT JOIN은 T1의 값은 다 띄우고 겹치치 않은 T2는 NULL값으로 띄운다
ON (T1.STUDENT_NO = T2.STUDENT_NO)
ORDER BY T1.STUDENT_NO;

SELECT *
FROM ACADEMY_A T1
FULL OUTER JOIN ACADEMY_B T2
ON (T1.STUDENT_NO = T2.STUDENT_NO)
ORDER BY T1.STUDENT_NO;

SELECT *
FROM ACADEMY_A T1, ACADEMY_B T2
WHERE T1.STUDENT_NO >= T2.STUDENT_NO;   --결과는 범위내에 전부 다 뜬다
--JOIN은 같은 것만 나오지만 여기서는 T2 < T1의 조건이 더 붙는다

SELECT *
FROM ACADEMY_A T1
NATURAL JOIN ACADEMY_B T2;
--NATURAL JOIN은 같은 이름을 가진 조건만 출력

CREATE TABLE ACADEMY_C (
    STUDENT_NO NUMBER PRIMARY KEY,
    STUDENT_NAME VARCHAR2(20) NOT NULL
);
INSERT INTO ACADEMY_C VALUES (1004, '김연아');
INSERT INTO ACADEMY_C VALUES (1006, '이윤아');
INSERT INTO ACADEMY_C VALUES (1001, '정소화');
INSERT INTO ACADEMY_C VALUES (1007, '정소화');

SELECT * FROM ACADEMY_A A
LEFT JOIN ACADEMY_B B
ON A.STUDENT_NO = B.STUDENT_NO
RIGHT JOIN ACADEMY_C C
ON C.STUDENT_NO = A.STUDENT_NO;

SELECT * FROM ACADEMY_A A
RIGHT JOIN ACADEMY_B B
ON A.STUDENT_NO = B.STUDENT_NO
LEFT JOIN ACADEMY_C C
ON C.STUDENT_NO = A.STUDENT_NO;

SELECT * FROM ACADEMY_A A
LEFT JOIN ACADEMY_B B
ON A.STUDENT_NO = B.STUDENT_NO
LEFT JOIN ACADEMY_C C
ON C.STUDENT_NO = A.STUDENT_NO;

--------------------문제풀기-----------------------

DROP TABLE EMP;
DROP TABLE DEPT;
CREATE TABLE DEPT (
    DEPT_NO      NUMBER PRIMARY KEY,
    DEPT_NAME    VARCHAR2(20) NOT NULL
);
CREATE TABLE EMP (
    EMP_NO      NUMBER PRIMARY KEY,
    EMP_NAME    VARCHAR2(20) NOT NULL,
    DEPT_NO NUMBER NOT NULL,
    CONSTRAINT FK_DEPT_NO FOREIGN KEY(DEPT_NO) REFERENCES DEPT (DEPT_NO)
);
INSERT INTO DEPT VALUES (1, '인사부');
INSERT INTO DEPT VALUES (2, '연구부');
INSERT INTO DEPT VALUES (3, '홍보부');
INSERT INTO EMP VALUES (1001, '정소화', 3);
INSERT INTO EMP VALUES (1002, '김용욱', 1);
INSERT INTO EMP VALUES (1003, '고명석', 2);

SELECT T1.DEPT_NAME, T2.EMP_NAME
FROM DEPT T1
NATURAL JOIN EMP T2;

SELECT T2.STUDENT_NO, T2.STUDENT_NAME, T3.CLASS_NAME
FROM CLASS_STUDENT T1
JOIN STUDENT T2
ON (T1.STUDENT_NO = T2.STUDENT_NO)
JOIN CLASS T3
ON(T1.CLASS_NO = T3.CLASS_NO);

-------------------------------------------------
SELECT * FROM ACADEMY_A
UNION ALL   --UNION ALL은 UNION과 다르게 중복허용하여 전부 출력한다
SELECT * FROM ACADEMY_B;

SELECT * FROM ACADEMY_A
UNION   --UNION은 중복데이터 제거한다
SELECT * FROM ACADEMY_B;

SELECT * FROM ACADEMY_A
INTERSECT   --중복된 부분만 가져온다
SELECT * FROM ACADEMY_B;

SELECT * FROM ACADEMY_A
MINUS -- MINUS는 A테이블에서 B테이블을 빼버린다(A와 B의 중복데이터 제거)
SELECT * FROM ACADEMY_B;

--------------서브 쿼리--------------------
SELECT T1.STUDENT_NO,
                (SELECT T2.STUDENT_NAME
                 FROM ACADEMY_B T2
                 WHERE T2.STUDENT_NO = T1.STUDENT_NO) AS NAME
FROM ACADEMY_A T1;` --서브쿼리를 안쓰면 중복된 값만 나오는데 서브쿼리를 쓰면 중복된 값이 아닌 전체리스트에 NULL값과 중복값을 띄운다          

SELECT T1.STUDENT_NO, T2.STUDENT_NAME
FROM ACADEMY_A T1,
    (SELECT STUDENT_NO, STUDENT_NAME
     FROM ACADEMY_B) T2
WHERE T1.STUDENT_NO = T2.STUDENT_NO;     

























